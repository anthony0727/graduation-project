
/********************************************************/
/*                                                      */
/*               WiSS Storage System                    */
/*          Version SystemV-4.0, September 1990	        */
/*                                                      */
/*              COPYRIGHT (C) 1990                      */
/*                David J. DeWitt 		        */
/*               Madison, WI U.S.A.                     */
/*                                                      */
/*	         ALL RIGHTS RESERVED                    */
/*                                                      */
/********************************************************/


#include "benchmark.h"
#include <stdio.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <strings.h>

#define	CHECKERR(p,c) if((int)(c)<0) fatalerror(p,(int)(c))

/************************************************************************

This program generates almost "standard" Wisconsin Benchmark relations 
in any size up to and including 100 million rows and loads them into
a WiSS file. Each relation has 13, four byte integer 
attributes and 3, 52 byte string attributes.  
The relation is clustered on the first attribute (a 4 byte integer).
The integer attributes are written in binary and the string 
attributes are written ASCII.  

This generator is based on a very similiar generator written in TAL 
by Susanne Englert of Tandem Computers.

The relations generated by this program differ slightly from early
versions in their specification of the attribute after the "twenty attribute"
in order to more facilitate more smooth scaling.  The new attributes
are documented below


  RELATION FORMAT:                                                     
                                                                      
  -------------------------------------------------------------------------
  |u1|u2|two|four|ten|twenty|1%|10%|20%|50%|u3|odd1%|even1%|str1|str2|str3|        
  -------------------------------------------------------------------------
                                                                      
                                                                     
  ATTRIBUTE DESCRIPTIONS:                                           
         u1: (unique1) a candidate key with values 0 to MAXTUPLES-1
	     in random order
         u2: (unique2) another candidate key with values 0 to MAXTUPLES-1 
	     in order.  u1 and u2 are not correlated with each other.
        two: twos, half the tuples have the value 0, the other half 1, 
             distribution is random                                    
       four: fours, divides the relation into quarters, range 0 - 3,   
             distribution is random                                    
        ten: tens, divides the relation into tenths, range 0 - 9,      
             distribution is random                                    
     twenty: twenties, divides the reln into twentieths, range 0 - 19, 
             distribution is random                                    
         1%: values between 0 and (MAXTUPLES/100 - 1) randomly distributed
        10%: values between 0 and (MAXTUPLES/10 - 1) randomly distributed
        20%: values between 0 and (MAXTUPLES/5 - 1) randomly distributed
        50%: values between 0 and (MAXTUPLES/2 - 1) randomly distributed
	 u3: equal to u1
      odd1%: odd values between 0 and ((2*MAXTUPLES)/100 - 1) randomly 
		distributed
     even1%: even values between 0 and ((2*MAXTUPLES)/100 - 1) randomly 
		distributed
       str1: string1, a random candidate key, consists of six significant      
             characters ('A'-'Z') followed by 46 x's providing 26**6 unique
	     combinations.
       str2: string2, candidate key, format is identical to str1, str2 
             varies as follows:                                        
                  AAAAAAxxx...                                          
                  BAAAAAxx...                                          
                  .                                                    
                  .                                                    
                  ZAAAAAxx...                                          
                  ABAAAAxx...                                          
                  .                                                    
                  .                                                    
                  ZBAAAAxx...                                          
                  ACAAAAxx...                                          
                  .                                                    
                  .                                                    
       str3: string3, assumes four values, AAAAxxx..., HHHHxxx...,     
             OOOOxxx..., and VVVVxxx... in a cyclic manner:            
                  AAAAxxx...                                           
                  HHHHxxx...                                           
                  OOOOxxx...                                           
                  VVVVxxx...                                           
                  AAAAxxx...                                           
                  HHHHxxx...                                           
                  OOOOxxx...                                           
                  VVVVxxx...                                           
                  .                                                    
                  .                                                    
                                                                       
  It should be noted that the user can choose alternate positions for  
  the significant characters (non x's) within the string attributes    
  simply by redefining the constants POS_ONE, POS_TWO, ... , POS_SIZ   
                                                                       
*/
 
#define STRLEN  	52
#define POS_ONE		0
#define POS_TWO		1
#define POS_THREE	2
#define POS_FOUR	3
#define POS_FIVE	4
#define POS_SIX		5
#define _26TOTHE1	26
#define _26TOTHE2	26*26
#define _26TOTHE3	26*26*26
#define _26TOTHE4	26*26*26*26
#define _26TOTHE5	26*26*26*26*26
#define ALPHABET_LEN    26

long	prime, generator;  

struct rusage	begtime;
struct rusage	endtime;

extern int	io_diskreads;
extern int	io_diskwrites;
extern TRACEFLAGS	Trace;

int transId;
int		verboseFlag;

main (argc, argv)
int argc;
char *argv[];
{
    int 	tupCount;  /* number of tuples in result relation */
    char	*relname;  /* name of output file */

    if (argc < 4) {
	printf("usage: relname tuple_count verboseFlag\n");
	exit(1);
    }

    relname = argv[1];
    tupCount = atoi (argv[2]);
    if (strcmp(argv[3], "TRUE") == 0) verboseFlag = TRUE;
    else verboseFlag = FALSE;

    printf("About to generate Wisconsin benchmark relation %s with %d tuples\n",
	relname, tupCount);
    
    /* The first step is to choose a prime and generator value 
       appropriate for the size of the table.  These values are taken directly
       from the Tandem benchmark generator 
    */

    if (tupCount <= 1000) /* 1,000 */
    {
	generator = 279;
	prime = 1009;
    }
    else
    if (tupCount <= 10000)  /* 10,000 tuples */
    {
	generator = 2969;
	prime = 10007;
    }
    else
    if (tupCount <= 100000) /* 100,000 tuples */
    {
	generator = 21395;
	prime = 100003;
    }
    else
    if (tupCount <= 1000000) /* 1 million tuples */
    {
	generator = 2107;
	prime = 1000003;
    }
    else
    if (tupCount <= 10000000)  /* 10 million tuples */
    {
	generator = 211;
	prime = 10000019;
    }
    else
    if (tupCount <= 100000000)  /* 100 million tuples */
    {
	generator = 21;
	prime = 100000007;
    }
    else
    {
	printf("too many rows requested\n");
	exit(1);
    }
    generate_relation(tupCount, relname);
}




generate_relation (tupCount, relname)
int tupCount;  /* number of tuples in relation */
char *relname;  /* name of output relation */
{
    int	 j, e, vol, f1, f2;
    RID	rid;
    char    c, *bufptr;
    long    startTime;		/* start time for load */
    long    totalTime;		/* total time for load */
    int	    recSize;

    TUPLE tuple;

    char str_char1,str_char2, str_char3,
	 str_char4, str_char5, str_char6, str_char7;

    char dummy1[8], dummy2[8], dummy3[8];

    int outfd;  /* output file descriptor */
    int outCount; 
    int current;
    int u1;
    long rand();
    long seed = generator;

    register int i;
    register TUPLE *tupPtr;
    register char *strPtr;

    /* warm up wiss */

    e = wiss_init();			
    CHECKERR("load/wiss_init", e);

    transId = begin_trans();
    printf("new transaction id = %d\n",transId);

    /* mount the volume */
    vol = wiss_mount(VOLUME);	
    CHECKERR("load/wiss_mount", vol);

    /* make sure the relation  does not exist already */
    (void) wiss_destroyfile(vol, relname, transId, FALSE, FALSE);

     /* 
     * Create and load the data file.
     */

    e = wiss_createfile(vol, relname, ((tupCount*sizeof(TUPLE))/PAGESIZE)+1,
		100, 100);
    printf("return from createf=%d\n",e);
    CHECKERR("load/wiss_createfile", e);


    /* initialize string variables */

    str_char1 = 'A'; str_char2 = 'A'; str_char3 = 'A'; str_char4 = 'A';
    str_char5 = 'A'; str_char6 = 'A'; str_char7 = 'A';

    /* initialize the string fields */
    tupPtr = &tuple;
    strPtr = &tupPtr->string1[0];
    for(i = 0; i < STRLEN; i++) *strPtr++ = 'x';
    strPtr = &tupPtr->string2[0];
    for(i = 0; i < STRLEN; i++) *strPtr++ = 'x';
    strPtr = &tupPtr->string3[0];
    for(i = 0; i < STRLEN; i++) *strPtr++ = 'x';

    /* generate tuples */

    current = 1;	/* tuple being generated */
    tupPtr = &tuple;

    startTime = time(0);  
    f1 = wiss_openfile(vol, relname, WRITE);
    CHECKERR("load/wiss_openfile", f1);

    e = wiss_lock_file(transId, f1, l_IX,  COMMIT,  FALSE);
    CHECKERR ("build/wiss_lock_file", e);

/*
    printf("  u1     u2  2  4  10  20   1Per 10Per 20Per 50Per   u3  even1Per  odd1Per  str1  str2  str3\n");

*/
    while (current <= tupCount)
    {
    	seed = rand(seed,(long)tupCount);  /* generate random number between 
				between 1 and tupCount */
	u1 = (int) seed - 1;
	tupPtr->unique1 = u1;
	tupPtr->unique2 = current - 1;
    	tupPtr->two = u1 % 2;
    	tupPtr->four = u1 % 4;
    	tupPtr->ten = u1 % 10;
    	tupPtr->twenty = u1 % 20;
    	tupPtr->onePercent = (int)u1 / 100;
    	tupPtr->tenPercent = (int)u1 / 10;
    	tupPtr->twentyPercent = (int)u1 / 5;
    	tupPtr->fiftyPercent = (int)u1 / 2;
	tupPtr->unique3 = u1;
	tupPtr->evenOnePercent = tupPtr->onePercent * 2;
	tupPtr->oddOnePercent = tupPtr->evenOnePercent + 1;

	/* produce string 1 - a unique 6 character string */

	strPtr = &tupPtr->string1[0];
	*(strPtr + POS_ONE) = (u1 % ALPHABET_LEN) + 'A';
	*(strPtr + POS_TWO) = ((u1 / _26TOTHE1) % ALPHABET_LEN) + 'A';
	*(strPtr + POS_THREE) = ((u1 / _26TOTHE2) % ALPHABET_LEN) + 'A';
	*(strPtr + POS_FOUR) = ((u1 / _26TOTHE3) % ALPHABET_LEN) + 'A';
	*(strPtr + POS_FIVE) = ((u1 / _26TOTHE4) % ALPHABET_LEN) + 'A';
	*(strPtr + POS_SIX) = ((u1 / _26TOTHE5) % ALPHABET_LEN) + 'A';

	/* produce string 2 */

	strPtr = &tupPtr->string2[0];
	*(strPtr + POS_ONE) = str_char1;
	*(strPtr + POS_TWO) = str_char2;
	*(strPtr + POS_THREE) = str_char3;
	*(strPtr + POS_FOUR) = str_char4;
	*(strPtr + POS_FIVE) = str_char5;
	*(strPtr + POS_SIX) = str_char6;

	str_char1++;
	if(str_char1 > 'Z')
	{
		str_char1 = 'A';
		str_char2++;
	}
	if(str_char2 > 'Z')
	{
		str_char2 = 'A';
		str_char3++;
	}
	if(str_char3 > 'Z')
	{
		str_char3 = 'A';
		str_char4++;
	}
	if(str_char4 > 'Z')
	{
		str_char4 = 'A';
		str_char5++;
	}
	if(str_char5 > 'Z')
	{
		str_char5 = 'A';
		str_char6++;
	}
	if(str_char6 > 'Z') str_char6 = 'A';


	/* produce string3 */
	strPtr = &tupPtr->string3[0];
	*(strPtr + POS_ONE) = str_char7;
	*(strPtr + POS_TWO) = str_char7;
	*(strPtr + POS_THREE) = str_char7;
	*(strPtr + POS_FOUR) = str_char7;
	str_char7 += 7;
	if(str_char7 > 'Z') str_char7 = 'A';  

	strncpy (dummy1, tupPtr->string1, 6);
	dummy1[6] = '\0';
	strncpy (dummy2, tupPtr->string2, 6);
	dummy2[6] = '\0';
	strncpy (dummy3, tupPtr->string3, 6);
	dummy3[6] = '\0';

/*
	printf("%5d %5d %2d %2d %3d %3d %5d %5d %5d %5d %5d %5d   %5d   %7s %7s %7s\n",
	tupPtr->unique1, tupPtr->unique2, tupPtr->two,
    	tupPtr->four, tupPtr->ten, tupPtr->twenty, tupPtr->onePercent,
    	tupPtr->tenPercent, tupPtr->twentyPercent, tupPtr->fiftyPercent,
	tupPtr->unique3, tupPtr->evenOnePercent, tupPtr->oddOnePercent,
	dummy1, dummy2, dummy3);
*/

	e = wiss_appendfile(f1, tupPtr, sizeof(TUPLE), &rid,
		transId, TRUE, FALSE);
	CHECKERR("load/wiss_appendfile", e);

	if (e < eNOERROR) 
 	{
		printf("%d error return from appendfile\n",e);
		break;
	}

	if ((current % 10000) == 0)
    		printf("Total # of tuples written = %d\n",current);

	current++;  /* increment  number of tuples generated */
    }
    /* now commit the transaction */
    e = commit_trans(transId);
    if (e != 1)
      printf("error status return from commit_trans = %d\n", e);
    else printf("commit ok\n");

    e = wiss_closefile(f1);
    CHECKERR("load/wiss_closefile", e);
    printf("closefile completed\n");

/*
    printf(" %d pages and %d records in %s\n", wiss_filepages(vol, relname),
		wiss_recordcard(vol, relname), relname);
*/
    /* dismount the volume */
    e = wiss_dismount(VOLUME);  
    CHECKERR("load/wiss_dismount", e);
    printf("dismount completed\n");

    if (verboseFlag)
    {
        totalTime = time(0) - startTime;
        printf("WISS took %d seconds to load %d records\n", 
		totalTime, current-1);
    }

    (void) wiss_final();
    printf("final completed\n");

}


long rand (seed, limit)
long seed, limit;
{
        do {
		seed = (generator * seed) % prime;
	    } while (seed > limit);
	return (seed);
}

fatalerror(p, e)
char *p; int e;
{
   printf("fatal error. first abort the transaction\n");
   wiss_abort_trans(transId);

   /* dismount the device */
   (void) wiss_dismount(VOLUME);  

   wiss_final();  /* clean up processes and shared memory segments */

   wiss_fatalerror(p,(int) e);
}
